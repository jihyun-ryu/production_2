<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sarcasm in Korean â€“ Speech Recording Experiment</title>

  <!-- jsPsych -->
  <link rel="stylesheet" href="https://unpkg.com/jspsych@8.0.0/css/jspsych.css">
  <script src="https://unpkg.com/jspsych@8.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@2.0.0"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
    }
    .recording-container {
      text-align: center;
      padding: 40px;
      max-width: 880px;
      margin: 0 auto;
    }
    .sentence-display {
      font-size: 28px;
      font-weight: bold;
      padding: 30px;
      margin: 30px 0 15px;
      background: #f7f7f7;
      border-radius: 12px;
      line-height: 1.6;
      word-break: keep-all;
    }
    .recording-status {
      font-size: 20px;
      margin: 18px 0 6px;
      min-height: 30px;
    }
    .recording-active {
      color: #dc3545;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: .35; }
    }
    .timer {
      font-size: 22px;
      font-weight: 700;
      margin: 6px 0 14px;
    }
    .control-buttons {
      margin-top: 18px;
    }
    .control-buttons button {
      font-size: 18px;
      padding: 14px 36px;
      margin: 0 8px;
      cursor: pointer;
    }
    .record-btn {
      background-color: #dc3545;
      color: #fff;
      border: none;
      border-radius: 8px;
    }
    .record-btn:hover:not(:disabled) { background-color: #c82333; }
    .stop-btn {
      background-color: #28a745;
      color: #fff;
      border: none;
      border-radius: 8px;
    }
    .stop-btn:hover:not(:disabled) { background-color: #218838; }
    .next-btn {
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 8px;
    }
    .next-btn:hover:not(:disabled) { background-color: #0069d9; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .form-container {
      text-align: left;
      max-width: 720px;
      margin: 0 auto;
      line-height: 1.7;
    }
    .form-container p { margin: 10px 0; }
    .form-container label {
      display: block;
      margin-bottom: 5px;
      font-weight: 700;
    }
    .form-container input[type="text"] {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
    }
    .form-container input[type="radio"] { margin: 0 6px 0 14px; }

    .pill {
      background:#ffe08a;
      padding:4px 10px;
      border-radius:999px;
      display:inline-block;
      font-size:16px;
      margin-bottom:6px;
    }
    .meta {
      margin-bottom: 10px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <div id="jspsych-target"></div>

  <script>
    /******************************************************
     * Sarcasm in Korean â€“ Speech Recording Experiment
     * (ê³½ì„±ë¯¼, ë¥˜ì§€í˜„) â€“ Production Study
     ******************************************************/

    console.log('Script starting...');

    /* ===== CONFIG ===== */
    const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbxuvD262zRN2QGQpGeLcolHOmI9VaQebydGEhSJSl0OMgZKpHZt-O3_2bhHOjXKXTBs/exec';

    /* ===== UI TEXTS ===== */
    const TEXTS = {
      welcomeTitle: 'Speech Recording Experiment',
      welcomeBody: 'í™”ë©´ì— í‘œì‹œë˜ëŠ” ë¬¸ì¥ì„ ìì—°ìŠ¤ëŸ½ê²Œ ì½ì–´ì£¼ì„¸ìš”.<br><strong>ì¡°ìš©í•œ í™˜ê²½ì—ì„œ ì§„í–‰í•´ì£¼ì„¸ìš”.</strong>',
      startBtn: 'Start',
      ready: 'ì¤€ë¹„ë˜ë©´ ë…¹ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”',
      recording: 'ğŸ”´ ë…¹ìŒ ì¤‘...',
      stopped: 'ë…¹ìŒì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.',
      recordBtn: 'ë…¹ìŒ ì‹œì‘',
      stopBtn: 'ë…¹ìŒ ì™„ë£Œ',
      nextBtn: 'ë‹¤ìŒ',
      endTitle: 'ê°ì‚¬í•©ë‹ˆë‹¤!',
      endBody: 'ì‹¤í—˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.',
      finishBtn: 'ì¢…ë£Œ'
    };

    /* ===== GLOBAL STATE ===== */
    let mediaRecorder = null;
    let audioChunks = [];
    let participantId = null;
    let demographicsData = null;
    let currentTimerInterval = null;
    let isRecording = false;

    /* ===== INIT ===== */
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      on_finish: () => console.log('Experiment finished')
    });

    /* ===== WELCOME ===== */
    const welcome = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `<h2>${TEXTS.welcomeTitle}</h2><p>${TEXTS.welcomeBody}</p>`,
      choices: [TEXTS.startBtn]
    };

    /* ===== INSTRUCTIONS (ì—°êµ¬ ì†Œê°œ/ë°©ë²•/ì£¼ì˜) ===== */
    const instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="form-container" style="max-width:800px;">
          <h2>ì•ˆë…•í•˜ì„¸ìš”.</h2>
          <p>ì €í¬ëŠ” <strong>ì˜ì–´ìŒì„±í•™í”„ë¡œì íŠ¸</strong> ìˆ˜ì—… ì¤‘ <em>Sarcasm in Korean</em>ì„ ì£¼ì œë¡œ ì—°êµ¬í•˜ê³  ìˆëŠ” <strong>ê³½ì„±ë¯¼, ë¥˜ì§€í˜„</strong>ì…ë‹ˆë‹¤.</p>
          <p><strong>7ê°€ì§€ ìƒí™©</strong>ì„ <strong>3ê°€ì§€ ë°©ì‹</strong>(ì¼ë°˜/ì§„ì‹¬/ë¹„ê¼¼)ìœ¼ë¡œ ë…¹ìŒí•˜ë©°, ì•½ <strong>5â€“10ë¶„</strong>ì´ ì†Œìš”ë©ë‹ˆë‹¤.<br>
          ìˆ˜ì§‘ëœ ìŒì„±ì€ <strong>ìŒì„± ë¶„ì„ í›„ ì¦‰ì‹œ íê¸°</strong>ë©ë‹ˆë‹¤.</p>

          <h3>ì°¸ì—¬ ë°©ë²•</h3>
          <ul>
            <li>ê° ìƒí™©ì—ëŠ” <strong>ê°•ì¡°ëœ ë‹¨ì–´</strong>(ì˜ˆ: â€œì˜í•œë‹¤â€)ê°€ ìˆìŠµë‹ˆë‹¤.</li>
            <li>í•´ë‹¹ ë‹¨ì–´ë¥¼ í‘œì‹œëœ <strong>ì„¸ ê°€ì§€ ë°©ì‹</strong>ìœ¼ë¡œ ê°ê° ë…¹ìŒí•©ë‹ˆë‹¤. <em>(ì œì‹œ ìˆœì„œëŠ” ë¬´ì‘ìœ„)</em></li>
            <li>(a) ì¼ë°˜ì  ë§í•˜ê¸° ë°©ì‹ &nbsp; (b) ì§„ì‹¬ìœ¼ë¡œ ë§í•˜ëŠ” ë°©ì‹ &nbsp; (c) ë¹„ê¼¬ëŠ”(í’ìì ) ë°©ì‹</li>
          </ul>

          <h3>ì£¼ì˜ ì‚¬í•­</h3>
          <ul>
            <li>ë¶€ì°©ëœ ë§ˆì´í¬ë¥¼ ì…ì—ì„œ <strong>ì•½ 10cm</strong> ë–¨ì–´ì§„ ìœ„ì¹˜ì— ë‘ê³  ë…¹ìŒí•´ì£¼ì„¸ìš”.</li>
            <li>ì£¼ë³€ ì†ŒìŒì„ ìµœì†Œí™”í•œ <strong>ì¡°ìš©í•œ í™˜ê²½</strong>ì—ì„œ ì§„í–‰í•´ì£¼ì„¸ìš”.</li>
            <li><strong>ìì—°ìŠ¤ëŸ¬ìš´ ë°œí™”</strong>ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤. ê³¼ì¥í•˜ì§€ ë§ê³  í‰ì†Œ ë§í•˜ë“¯ì´ ì½ì–´ì£¼ì„¸ìš”.</li>
          </ul>

          <p style="color:#d93025; font-weight:bold; font-size:18px; margin-top:25px;">
            âš ï¸ <u>ìˆ˜ë„ê¶Œ(ì„œìš¸Â·ê²½ê¸°Â·ì¸ì²œ) ì´ì™¸ ì§€ì—­ ë°©ì–¸ì„ ì‚¬ìš©í•˜ì‹œëŠ” ë¶„ì€ ë³¸ ì‹¤í—˜ì— ì°¸ì—¬í•˜ì‹¤ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</u>
          </p>
        </div>
      `,
      choices: ['ì‹œì‘í•˜ê¸°']
    };

    /* ===== DEMOGRAPHICS ===== */
    const demographics = {
      type: jsPsychSurveyHtmlForm,
      preamble: '<h3>ì°¸ê°€ì ì •ë³´</h3><p>ì‹¤í—˜ì„ ì‹œì‘í•˜ê¸° ì „ì— ì•„ë˜ ì •ë³´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.</p>',
      html: `
        <div class="form-container">
          <p>
            <label for="gender">ì„±ë³„:</label>
            <input type="radio" name="gender" value="ë‚¨" required> ë‚¨
            <input type="radio" name="gender" value="ì—¬" required> ì—¬
          </p>
          <p>
            <label for="birth_year">íƒœì–´ë‚œ í•´:</label>
            <input type="text" id="birth_year" name="birth_year" placeholder="YYYY (ì˜ˆ: 1995)" pattern="[0-9]{4}" required style="width: 150px;">
          </p>
          <p>
            <label for="birth_month">íƒœì–´ë‚œ ì›”:</label>
            <input type="text" id="birth_month" name="birth_month" placeholder="MM (ì˜ˆ: 03)" pattern="[0-9]{1,2}" required style="width: 80px;">
          </p>
          <p>
            <label for="native_lang">ëª¨êµ­ì–´:</label>
            <input type="text" id="native_lang" name="native_lang" placeholder="ì˜ˆ: í•œêµ­ì–´" required style="width: 200px;">
          </p>
          <p>
            <label for="dialect">ë°©ì–¸:</label>
            <input type="text" id="dialect" name="dialect" placeholder="ì˜ˆ: ì„œìš¸, ê²½ìƒë„" style="width: 200px;">
          </p>
        </div>
      `,
      button_label: 'ë…¹ìŒ ì‹œì‘í•˜ê¸°',
      data: { task: 'demographics' },
      on_finish: (data) => {
        demographicsData = data.response;
        participantId = 'P' + Date.now();
        data.participant_id = participantId;
        data.timestamp = new Date().toISOString();
        console.log('=== Demographics saved ===', participantId, demographicsData);
      }
    };

    /* ===== MICROPHONE PERMISSION ===== */
    const mic_permission = {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<h3>ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­</h3><p>ë…¹ìŒì„ ìœ„í•´ ë§ˆì´í¬ ì‚¬ìš©ì„ í—ˆìš©í•´ì£¼ì„¸ìš”.</p>',
      choices: ['ë§ˆì´í¬ í—ˆìš©'],
      on_finish: async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach(track => track.stop());
          console.log('Microphone permission granted');
        } catch (err) {
          alert('ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ë§ˆì´í¬ë¥¼ í—ˆìš©í•´ì£¼ì„¸ìš”.');
          console.error('Microphone error:', err);
        }
      }
    };

    /* ===== 7 í‚¤ì›Œë“œ Ã— (ì„¸ ê°€ì§€ ë°©ì‹) ì •ì˜ ===== */
    const SCENARIOS = [
      {
        keyword: "ì˜í•œë‹¤",
        items: [
          { style: "ì¼ë°˜ ëŒ€í™”",     label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ê³¼ì œë¥¼ ì œì¶œí•˜ê³  'ì˜í–ˆì§€?'ë¼ê³  ë¬¼ì„ ë•Œ",                 sentence: "ì˜í•œë‹¤" },
          { style: "ì§„ì‹¬ìœ¼ë¡œ",       label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ê³¼ì œì—ì„œ 1ë“±ì„ í•˜ê³  'ë‚˜ ì˜í–ˆì§€?'ë¼ê³  ë§í•  ë•Œ",         sentence: "ì˜í•œë‹¤" },
          { style: "ë¹„ê¼¬ëŠ” ë§íˆ¬ë¡œ",  label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ê³¼ì œë¥¼ ê²¨ìš° ì œì¶œí•˜ê³  'ë‚˜ ì˜í–ˆì§€?'ë¼ê³  ë§í•  ë•Œ",         sentence: "ì˜í•œë‹¤" },
        ]
      },
      {
        keyword: "ëŒ€ë‹¨í•˜ë‹¤",
        items: [
          { style: "ì¼ë°˜ ëŒ€í™”",     label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ì‹œí—˜ì„ ëë‚´ê³  ì™”ì„ ë•Œ",                                 sentence: "ëŒ€ë‹¨í•˜ë‹¤" },
          { style: "ì§„ì‹¬ìœ¼ë¡œ",       label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ì‹œí—˜ì„ ì •ë§ ì—´ì‹¬íˆ ì¤€ë¹„í•´ì„œ ë†’ì€ ì ìˆ˜ë¥¼ ë°›ì•˜ì„ ë•Œ",     sentence: "ëŒ€ë‹¨í•˜ë‹¤" },
          { style: "ë¹„ê¼¬ëŠ” ë§íˆ¬ë¡œ",  label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ê±°ì˜ ìš´ìœ¼ë¡œ ë†’ì€ ì ìˆ˜ë¥¼ ë°›ì•˜ë‹¤ê³  ì‹ ë‚˜ ìˆì„ ë•Œ",         sentence: "ëŒ€ë‹¨í•˜ë‹¤" },
        ]
      },
      {
        keyword: "ì¢‹ì•˜ì–´",
        items: [
          { style: "ì¼ë°˜ ëŒ€í™”",     label: "ìƒí™©", context: "ë°œí‘œë¥¼ ë¬´ë‚œíˆ ë§ˆì¹œ ìƒí™©ì—ì„œ 'ì–´ë• ì–´?'ë¼ê³  ë¬¼ì„ ë•Œ",             sentence: "ì¢‹ì•˜ì–´" },
          { style: "ì§„ì‹¬ìœ¼ë¡œ",       label: "ìƒí™©", context: "ë°œí‘œë¥¼ ìœ ì°½í•˜ê²Œ ì˜ ëë‚¸ ì¹œêµ¬ê°€ 'ì¢‹ì•˜ì§€?'ë¼ê³  ë¬¼ì„ ë•Œ",         sentence: "ì¢‹ì•˜ì–´" },
          { style: "ë¹„ê¼¬ëŠ” ë§íˆ¬ë¡œ",  label: "ìƒí™©", context: "ì¤€ë¹„ ì—†ì´ ë°œí‘œí•˜ê³ ë„ ë‹¹ë‹¹í•œ ì¹œêµ¬ê°€ 'ì¢‹ì•˜ì§€?'ë¼ê³  ë§í•  ë•Œ",     sentence: "ì¢‹ì•˜ì–´" },
        ]
      },
      {
        keyword: "ëŒ€ë°•ì´ë‹¤",
        items: [
          { style: "ì¼ë°˜ ëŒ€í™”",     label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ìš´ë™ì„ ë‹¤ë…€ì™”ë‹¤ê³  ë§í•  ë•Œ",                             sentence: "ëŒ€ë°•ì´ë‹¤" },
          { style: "ì§„ì‹¬ìœ¼ë¡œ",       label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ê¾¸ì¤€íˆ ìš´ë™í•´ì„œ ì²´ë ¥ì´ ì¢‹ì•„ì§„ ê±¸ ë³´ì—¬ì¤„ ë•Œ",           sentence: "ëŒ€ë°•ì´ë‹¤" },
          { style: "ë¹„ê¼¬ëŠ” ë§íˆ¬ë¡œ",  label: "ìƒí™©", context: "ì´í‹€ ìš´ë™í•´ë†“ê³  'ë‚˜ ë²Œì¨ ë‹¬ë¼ì¡Œì§€?' í•˜ëŠ” ì¹œêµ¬ì—ê²Œ",            sentence: "ëŒ€ë°•ì´ë‹¤" },
        ]
      },
      {
        keyword: "ì°¸ ì˜í•´",
        items: [
          { style: "ì¼ë°˜ ëŒ€í™”",     label: "ìƒí™©", context: "ì¹œêµ¬ê°€ í‰ë²”í•˜ê²Œ ìš”ë¦¬í–ˆì„ ë•Œ",                                   sentence: "ì°¸ ì˜í•´" },
          { style: "ì§„ì‹¬ìœ¼ë¡œ",       label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ì •ì„± ë“¤ì—¬ ìš”ë¦¬í•´ì„œ ì •ë§ ë§›ìˆì„ ë•Œ",                    sentence: "ì°¸ ì˜í•´" },
          { style: "ë¹„ê¼¬ëŠ” ë§íˆ¬ë¡œ",  label: "ìƒí™©", context: "ë§›ì€ ë³„ë¡ ë° ì¹œêµ¬ê°€ ìŠ¤ìŠ¤ë¡œ ì¹­ì°¬í•  ë•Œ",                          sentence: "ì°¸ ì˜í•´" },
        ]
      },
      {
        keyword: "ë©‹ìˆë‹¤",
        items: [
          { style: "ì¼ë°˜ ëŒ€í™”",     label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ì¼ìƒì„ ì„±ì‹¤íˆ í•´ë‚¸ ë³´í†µì˜ ìƒí™©ì—ì„œ",                     sentence: "ë©‹ìˆë‹¤" },
          { style: "ì§„ì‹¬ìœ¼ë¡œ",       label: "ìƒí™©", context: "ì¹œêµ¬ê°€ í˜ë“  ìƒí™©ì„ ì°¸ì•„ë‚´ê³  ê²°êµ­ íšŒë³µí–ˆì„ ë•Œ",                 sentence: "ë©‹ìˆë‹¤" },
          { style: "ë¹„ê¼¬ëŠ” ë§íˆ¬ë¡œ",  label: "ìƒí™©", context: "ë³„ì¼ ì•„ë‹Œ ê±¸ ì—„ì²­ ê³ ìƒí•œ ê²ƒì²˜ëŸ¼ ë§í•  ë•Œ",                      sentence: "ë©‹ìˆë‹¤" },
        ]
      },
      {
        keyword: "ì—­ì‹œ",
        items: [
          { style: "ì¼ë°˜ ëŒ€í™”",     label: "ìƒí™©", context: "ì¹œêµ¬ê°€ í‰ì†Œì²˜ëŸ¼ ì•½ì†ì„ ì§€í‚¨ ìƒí™©ì—ì„œ",                           sentence: "ì—­ì‹œ" },
          { style: "ì§„ì‹¬ìœ¼ë¡œ",       label: "ìƒí™©", context: "ì¹œêµ¬ê°€ ì•½ì† ì‹œê°„ì„ ì˜ ë§ì¶°ì„œ ë„ì°©í–ˆì„ ë•Œ",                     sentence: "ì—­ì‹œ" },
          { style: "ë¹„ê¼¬ëŠ” ë§íˆ¬ë¡œ",  label: "ìƒí™©", context: "í•­ìƒ ëŠ¦ëŠ” ì¹œêµ¬ê°€ ë˜ ëŠ¦ê³  'ê·¸ë˜ë„ ë§ì´ ì•ˆ ëŠ¦ì—ˆì§€?' í•  ë•Œ",       sentence: "ì—­ì‹œ" },
        ]
      },
    ];

    // 7Ã—3 = 21ê°œ í•­ëª© í‰íƒ„í™” í›„ ë¬´ì‘ìœ„ ì…”í”Œ
    const TRIAL_ITEMS = jsPsych.randomization.shuffle(
      SCENARIOS.flatMap(s =>
        s.items.map(it => ({
          keyword: s.keyword,
          sentence: it.sentence,
          context_label: it.label,
          context_text: it.context,
          style: it.style
        }))
      )
    );

    /* ===== RECORDING TRIAL FACTORY ===== */
    function makeRecordingTrial(item, index) {
      const { sentence, keyword, context_label, context_text, style } = item;
      return {
        type: jsPsychHtmlButtonResponse,
        stimulus: () => `
          <div class="recording-container">
            <div class="sentence-display">
              <span class="pill">í‚¤ì›Œë“œ: <strong>${keyword}</strong></span><br>
              <span style="font-size:24px;">â€œ${sentence}â€</span>
            </div>
            <div class="meta"><strong>${context_label}</strong> Â· ${context_text}</div>
            <div class="meta"><strong>ìš”ì²­ëœ ë°©ì‹:</strong> ${style} ë§í•˜ê¸°</div>

            <div class="recording-status" id="status">${TEXTS.ready}</div>
            <div class="timer" id="timer"></div>

            <div class="control-buttons">
              <button class="record-btn" id="recordBtn" onclick="handleRecord()">${TEXTS.recordBtn}</button>
              <button class="stop-btn" id="stopBtn" onclick="handleStop()" disabled>${TEXTS.stopBtn}</button>
              <button class="next-btn" id="nextBtn" style="display:none;">${TEXTS.nextBtn}</button>
            </div>
          </div>
        `,
        choices: [],
        on_load: function () {
          console.log(`\n=== Trial ${index + 1} / ${TRIAL_ITEMS.length} ===`, item);
          audioChunks = [];
          isRecording = false;

          // ë…¹ìŒ ì‹œì‘
          window.handleRecord = async () => {
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            const statusEl = document.getElementById('status');

            if (isRecording) return;

            try {
              await startRecording();
              isRecording = true;

              recordBtn.disabled = true;
              stopBtn.disabled = false;

              if (statusEl) {
                statusEl.innerHTML = TEXTS.recording;
                statusEl.classList.add('recording-active');
              }

              // íƒ€ì´ë¨¸
              let seconds = 0;
              currentTimerInterval = setInterval(() => {
                seconds++;
                const timerEl = document.getElementById('timer');
                if (timerEl) timerEl.textContent = `${seconds}ì´ˆ`;
              }, 1000);

              console.log('Recording started');
            } catch (err) {
              console.error('Failed to start recording:', err);
              alert('ë…¹ìŒ ì‹œì‘ ì‹¤íŒ¨: ' + err.message);
            }
          };

          // ë…¹ìŒ ì¤‘ì§€ + ì—…ë¡œë“œ
          window.handleStop = async () => {
            const stopBtn = document.getElementById('stopBtn');
            const nextBtn = document.getElementById('nextBtn');
            const statusEl = document.getElementById('status');

            if (!isRecording) return;
            stopBtn.disabled = true;

            try {
              if (statusEl) {
                statusEl.innerHTML = 'ë…¹ìŒ ì¤‘ì§€ ì¤‘...';
                statusEl.classList.remove('recording-active');
              }

              await stopRecording();
              isRecording = false;

              // íƒ€ì´ë¨¸ ì •ì§€
              if (currentTimerInterval) {
                clearInterval(currentTimerInterval);
                currentTimerInterval = null;
              }

              console.log('Recording stopped, chunks:', audioChunks.length);

              // WAV ë³€í™˜ ë° ì—…ë¡œë“œ
              if (audioChunks.length > 0) {
                if (statusEl) statusEl.innerHTML = 'WAV ë³€í™˜ ì¤‘...';
                const webmBlob = new Blob(audioChunks, { type: 'audio/webm' });
                console.log('WebM size:', webmBlob.size, 'bytes');

                const wavBlob = await convertWebMToWav(webmBlob);
                console.log('WAV size:', wavBlob.size, 'bytes');

                if (statusEl) statusEl.innerHTML = 'â³ ì„œë²„ì— ì—…ë¡œë“œ ì¤‘...';

                const success = await uploadSingleRecording({
                  sentence,
                  index,
                  blob: wavBlob,
                  timestamp: new Date().toISOString(),
                  meta: { keyword, context_label, context_text, style }
                });

                if (success) {
                  console.log(`âœ“ Upload successful for trial ${index + 1}`);
                  if (statusEl) statusEl.innerHTML = 'âœ… ì—…ë¡œë“œ ì™„ë£Œ!';
                } else {
                  console.error(`âœ— Upload failed for trial ${index + 1}`);
                  if (statusEl) statusEl.innerHTML = 'âŒ ì—…ë¡œë“œ ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.';
                }
              } else {
                if (statusEl) statusEl.innerHTML = 'âš ï¸ ë…¹ìŒëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.';
              }

              // ë‹¤ìŒ ë²„íŠ¼
              if (nextBtn) {
                nextBtn.style.display = 'inline-block';
                nextBtn.onclick = () => {
                  jsPsych.finishTrial({
                    task: 'recording',
                    sentence,
                    sentence_index: index,
                    keyword,
                    context_label,
                    context_text,
                    style,
                    timestamp: new Date().toISOString()
                  });
                };
              }

            } catch (err) {
              console.error('Error during stop:', err);
              if (statusEl) statusEl.innerHTML = 'âŒ ì˜¤ë¥˜: ' + err.message;

              if (nextBtn) {
                nextBtn.style.display = 'inline-block';
                nextBtn.onclick = () => {
                  jsPsych.finishTrial({
                    task: 'recording',
                    sentence,
                    sentence_index: index,
                    keyword,
                    context_label,
                    context_text,
                    style,
                    error: err.message,
                    timestamp: new Date().toISOString()
                  });
                };
              }
            }
          };
        }
      };
    }

    /* ===== RECORDING CORE ===== */
    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { channelCount: 1, sampleRate: 16000 }
        });

        audioChunks = []; // reset

        const options = { mimeType: 'audio/webm' };
        mediaRecorder = new MediaRecorder(stream, options);

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
            console.log('Audio chunk received:', event.data.size, 'bytes');
          }
        };

        mediaRecorder.onerror = (event) => {
          console.error('MediaRecorder error:', event);
        };

        mediaRecorder.start(100); // collect every 100 ms
        console.log('MediaRecorder started');
      } catch (err) {
        console.error('Recording start error:', err);
        throw err;
      }
    }

    function stopRecording() {
      return new Promise((resolve, reject) => {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') {
          console.log('MediaRecorder already inactive');
          resolve();
          return;
        }

        const timeout = setTimeout(() => reject(new Error('Recording stop timeout')), 5000);

        mediaRecorder.onstop = () => {
          clearTimeout(timeout);
          mediaRecorder.stream.getTracks().forEach(track => track.stop());
          console.log('MediaRecorder stopped and tracks released');
          resolve();
        };

        try { mediaRecorder.stop(); }
        catch (err) {
          clearTimeout(timeout);
          reject(err);
        }
      });
    }

    /* ===== WEBM â†’ WAV ===== */
    async function convertWebMToWav(webmBlob) {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await webmBlob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

        console.log('Audio decoded:', {
          duration: audioBuffer.duration,
          sampleRate: audioBuffer.sampleRate,
          channels: audioBuffer.numberOfChannels
        });

        const wavBlob = audioBufferToWav(audioBuffer);
        await audioContext.close();
        return wavBlob;
      } catch (err) {
        console.error('WAV conversion error:', err);
        throw new Error('WAV ë³€í™˜ ì‹¤íŒ¨: ' + err.message);
      }
    }

    function audioBufferToWav(audioBuffer) {
      const numChannels = 1;       // mono
      const sampleRate = audioBuffer.sampleRate;
      const format = 1;            // PCM
      const bitDepth = 16;

      const bytesPerSample = bitDepth / 8;
      const blockAlign = numChannels * bytesPerSample;

      // use channel 0
      const source = audioBuffer.getChannelData(0);
      const samples = new Float32Array(source.length);
      samples.set(source);

      // PCM buffer
      const dataLength = samples.length * 2;
      const buffer = new ArrayBuffer(44 + dataLength);
      const view = new DataView(buffer);

      // RIFF/WAVE header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataLength, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true); // PCM
      view.setUint16(22, 1, true); // mono
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true); // byte rate
      view.setUint16(32, 2, true); // block align
      view.setUint16(34, 16, true); // bits per sample
      writeString(view, 36, 'data');
      view.setUint32(40, dataLength, true);

      // PCM samples
      let offset = 44;
      for (let i = 0; i < samples.length; i++) {
        const s = Math.max(-1, Math.min(1, samples[i]));
        const int16 = s < 0 ? s * 0x8000 : s * 0x7FFF;
        view.setInt16(offset, int16, true);
        offset += 2;
      }
      return new Blob([buffer], { type: 'audio/wav' });
    }
    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
    }

    /* ===== UPLOAD: Google Apps Script ===== */
    async function uploadSingleRecording(recordingData) {
      if (!GAS_ENDPOINT || GAS_ENDPOINT === 'YOUR_APPS_SCRIPT_URL') {
        console.error('Google Apps Script endpoint not configured!');
        alert('ì—…ë¡œë“œ ì‹¤íŒ¨: Google Apps Script URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        return false;
      }
      if (!demographicsData) {
        console.error('Demographics data not available!');
        alert('ì°¸ê°€ì ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        return false;
      }

      try {
        const base64Audio = await blobToBase64(recordingData.blob);
        const payload = {
          participant_id: participantId,
          sentence_index: recordingData.index,
          sentence: recordingData.sentence,
          audio_data: base64Audio,
          timestamp: recordingData.timestamp,
          demographics: demographicsData,
          meta: recordingData.meta // keyword, context_label, context_text, style
        };

        console.log('=== Uploading ===', payload);

        await fetch(GAS_ENDPOINT, {
          method: 'POST',
          mode: 'no-cors',                 // CORS ìš°íšŒìš©
          headers: { 'Content-Type': 'text/plain' }, // no-cors í—ˆìš© í—¤ë”
          body: JSON.stringify(payload)
        });

        console.log('Upload request sent (no-cors mode)');
        return true;
      } catch (err) {
        console.error('Upload error:', err);
        alert(`ì—…ë¡œë“œ ì‹¤íŒ¨: ${err.message}`);
        return false;
      }
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const base64 = reader.result.split(',')[1];
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    /* ===== END ===== */
    const end = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `<h2>${TEXTS.endTitle}</h2><p>${TEXTS.endBody}</p><p>ëª¨ë“  ë…¹ìŒ íŒŒì¼ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</p>`,
      choices: [TEXTS.finishBtn]
    };

    /* ===== BUILD & RUN TIMELINE ===== */
    const recording_trials = TRIAL_ITEMS.map((item, idx) => makeRecordingTrial(item, idx));

    console.log('Starting experiment...');
    jsPsych.run([
      welcome,
      instructions,      // ì—°êµ¬ ì•ˆë‚´ + ìˆ˜ë„ê¶Œ ì œí•œ ë¬¸êµ¬
      demographics,
      mic_permission,
      ...recording_trials,
      end
    ]);
  </script>
</body>
</html>


